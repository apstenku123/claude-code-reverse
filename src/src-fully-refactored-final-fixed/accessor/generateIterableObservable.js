/**
 * Creates an observable that emits values generated by iteratively applying a function,
 * optionally conditioned and scheduled. Supports both parameter and config object signatures.
 *
 * @param {Object|any} initialStateOrConfig - Either the initial state value or a config object.
 * @param {Function} [condition] - Predicate function to determine if iteration should continue.
 * @param {Function} [iterate] - Function to produce the next state from the current state.
 * @param {Function} [resultSelector] - Function to select the value to emit from the current state.
 * @param {Scheduler} [scheduler] - Optional scheduler to control emission timing.
 * @returns {Observable} An observable emitting the sequence of generated values.
 */
function generateIterableObservable(initialStateOrConfig, condition, iterate, resultSelector, scheduler) {
  let initialState;
  let conditionFn;
  let iterateFn;
  let resultSelectorFn;
  let schedulerInstance;

  // Support both config object and parameter signatures
  if (arguments.length === 1) {
    // Config object signature
    const config = initialStateOrConfig;
    initialState = config.initialState;
    conditionFn = config.condition;
    iterateFn = config.iterate;
    resultSelectorFn = config.resultSelector === undefined ? BNA.identity : config.resultSelector;
    schedulerInstance = config.scheduler;
  } else {
    // Parameter signature
    initialState = initialStateOrConfig;
    if (!resultSelector || CO9.isScheduler(resultSelector)) {
      // resultSelector omitted, scheduler provided
      resultSelectorFn = BNA.identity;
      schedulerInstance = resultSelector;
    } else {
      resultSelectorFn = resultSelector;
    }
  }

  /**
   * Generator function that yields values as long as the condition is met.
   * Used internally to create the iterable for the observable.
   */
  function generatorFunction() {
    let currentState;
    // XO9 is assumed to be a helper for generator/async iteration
    return XO9(this, function (context) {
      switch (context.label) {
        case 0:
          currentState = initialState;
          context.label = 1;
        case 1:
          // If no condition function is provided, or condition passes, continue
          if (!conditionFn || conditionFn(currentState)) {
            // Yield the result of resultSelectorFn(currentState)
            return [4, resultSelectorFn(currentState)];
          }
          // Condition failed, exit
          return [3, 4];
        case 2:
          // After yielding, move to next state
          context.sent();
          context.label = 3;
        case 3:
          // Update state and repeat
          currentState = iterateFn(currentState);
          return [3, 1];
        case 4:
          // Done
          return [2];
      }
    });
  }

  // If a scheduler is provided, defer and schedule the iterable; otherwise, just defer the generator
  return VO9.defer(schedulerInstance
    ? function () { return KO9.scheduleIterable(generatorFunction(), schedulerInstance); }
    : generatorFunction
  );
}

module.exports = generateIterableObservable;