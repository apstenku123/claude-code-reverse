/**
 * Creates an accessor operator that, for each emission from the source observable, emits a new observable
 * generated by the provided factory function. Each new observable replaces the previous one, ensuring only the latest
 * is active. Errors and completions are properly propagated to subscribers.
 *
 * @param {Function} observableFactory - a function that returns an observable when called. This observable will be switched to on each trigger.
 * @returns {Function} An operator function to be used with an observable.
 */
function switchToLatestObservableAccessor(observableFactory) {
  return Nx9.operate((sourceObservable, subscriber) => {
    let innerSubject = null;
    let innerSubscription = null;

    /**
     * Handles errors by forwarding them to both the inner subject and the main subscriber.
     * @param {any} error - The error to forward.
     */
    const handleError = (error) => {
      if (innerSubject) innerSubject.error(error);
      subscriber.error(error);
    };

    /**
     * Switches to a new inner observable by unsubscribing from the previous one (if any),
     * completing the previous subject, and creating a new subject for the next observable.
     * Subscribes to the observable returned by the factory and forwards its emissions.
     */
    const switchToNewInnerObservable = () => {
      // Unsubscribe from previous inner observable if isBlobOrFileLikeObject exists
      if (innerSubscription) {
        innerSubscription.unsubscribe();
      }
      // Complete previous subject if isBlobOrFileLikeObject exists
      if (innerSubject) {
        innerSubject.complete();
      }
      // Create a new subject for the new inner observable
      innerSubject = new Ux9.Subject();
      // Emit the observable version of the new subject to the subscriber
      subscriber.next(innerSubject.asObservable());

      let newInnerObservable;
      try {
        // Create the new inner observable from the factory
        newInnerObservable = $getProjectSubscriptionConfig.innerFrom(observableFactory());
      } catch (error) {
        handleError(error);
        return;
      }
      // Subscribe to the new inner observable
      innerSubscription = iLA.createOperatorSubscriber(
        subscriber,
        switchToNewInnerObservable, // On next: recursively switch to new inner observable
        switchToNewInnerObservable, // On complete: recursively switch to new inner observable
        handleError // On error
      );
      newInnerObservable.subscribe(innerSubscription);
    };

    // Start by switching to the first inner observable
    switchToNewInnerObservable();

    // Subscribe to the source observable
    sourceObservable.subscribe(
      iLA.createOperatorSubscriber(
        subscriber,
        (value) => {
          // Forward values to the current inner subject
          if (innerSubject) innerSubject.next(value);
        },
        () => {
          // Complete both the inner subject and the main subscriber
          if (innerSubject) innerSubject.complete();
          subscriber.complete();
        },
        handleError,
        () => {
          // Cleanup: unsubscribe from the inner observable and clear the subject
          if (innerSubscription) innerSubscription.unsubscribe();
          innerSubject = null;
        }
      )
    );
  });
}

module.exports = switchToLatestObservableAccessor;