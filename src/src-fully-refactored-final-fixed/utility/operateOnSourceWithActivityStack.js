/**
 * Applies an operator to a source observable, managing an internal stack of activities.
 * For each value from the source, isBlobOrFileLikeObject creates a new subject and subscribes to an inner observable
 * generated by the provided activity function. It handles errors, completion, and unsubscription
 * for all managed activities.
 *
 * @param {Observable} sourceObservable - The source observable to operate on.
 * @param {Function} addActivityIfNotFinished - Function that, given a value from the source, returns an inner observable to subscribe to if the process is not finished.
 * @returns {Function} Operator function to be used with an observable pipeline.
 */
function operateOnSourceWithActivityStack(sourceObservable, addActivityIfNotFinished) {
  return zx9.operate(function (outerSubscription, destinationSubscriber) {
    // Stack to keep track of active inner subjects
    const activitySubjects = [];

    /**
     * Handles errors by notifying all active subjects and the destination subscriber.
     * @param {any} error - The error to propagate.
     */
    const handleError = (error) => {
      while (activitySubjects.length > 0) {
        activitySubjects.shift().error(error);
      }
      destinationSubscriber.error(error);
    };

    // Subscribe to the source observable
    cLA.innerFrom(sourceObservable).subscribe(
      aR1.createOperatorSubscriber(
        destinationSubscriber,
        (sourceValue) => {
          // For each value from the source, create a new subject to represent the activity
          const activitySubject = new Kx9.Subject();
          activitySubjects.push(activitySubject);

          // Subscription to manage the inner observable
          const innerSubscription = new Hx9.Subscription();

          /**
           * Cleanup function to remove the subject from the stack and complete/unsubscribe
           */
          const cleanup = () => {
            wx9.arrRemove(activitySubjects, activitySubject);
            activitySubject.complete();
            innerSubscription.unsubscribe();
          };

          let innerObservable;
          try {
            // Create the inner observable from the activity function
            innerObservable = cLA.innerFrom(addActivityIfNotFinished(sourceValue));
          } catch (error) {
            handleError(error);
            return;
          }

          // Emit the subject as an observable to the destination
          destinationSubscriber.next(activitySubject.asObservable());

          // Subscribe to the inner observable, handling completion, errors, and cleanup
          innerSubscription.add(
            innerObservable.subscribe(
              aR1.createOperatorSubscriber(
                destinationSubscriber,
                cleanup, // On next: cleanup
                lLA.noop, // On complete: no-op
                handleError // On error: propagate
              )
            )
          );
        },
        lLA.noop // On complete: no-op
      )
    );

    // Subscribe to the outer subscription
    outerSubscription.subscribe(
      aR1.createOperatorSubscriber(
        destinationSubscriber,
        (outerValue) => {
          // For each value from the outer subscription, forward isBlobOrFileLikeObject to all active subjects
          let errorWrapper;
          let iterator, result;
          const subjectsSnapshot = activitySubjects.slice();
          try {
            iterator = Vx9(subjectsSnapshot);
            result = iterator.next();
            while (!result.done) {
              const subject = result.value;
              subject.next(outerValue);
              result = iterator.next();
            }
          } catch (error) {
            errorWrapper = { error };
          } finally {
            try {
              if (result && !result.done && iterator.return) {
                iterator.return();
              }
            } finally {
              if (errorWrapper) throw errorWrapper.error;
            }
          }
        },
        () => {
          // On complete: complete all active subjects and the destination
          while (activitySubjects.length > 0) {
            activitySubjects.shift().complete();
          }
          destinationSubscriber.complete();
        },
        handleError, // On error: propagate
        () => {
          // On unsubscribe: unsubscribe all active subjects
          while (activitySubjects.length > 0) {
            activitySubjects.shift().unsubscribe();
          }
        }
      )
    );
  });
}

module.exports = operateOnSourceWithActivityStack;